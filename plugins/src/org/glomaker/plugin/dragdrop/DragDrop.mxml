<?xml version="1.0" encoding="utf-8"?>

<!--
/////////////////////////////////////////////////////////////////////////
// Copyright (c) 2007-12 LTRI, London Metropolitan Uni. All rights reserved.
// An Open Source Release under the GPL v3 licence  (see http://www.gnu.org/licenses/).
// Authors: Tom Boyle, Nils Millahn, Musbah Sagar, Martin Agombar.
// See http://www.glomaker.org for full details
/////////////////////////////////////////////////////////////////////////
-->

<BaseComponent
	xmlns="org.glomaker.shared.component.*" 
	xmlns:mx="http://www.adobe.com/2006/mxml"
	layout="absolute"
	horizontalScrollPolicy="off"
	verticalScrollPolicy="off" xmlns:dragdrop="org.glomaker.plugin.dragdrop.*" xmlns:editbutton="org.glomaker.shared.ui.editbutton.*"
>
	<mx:Script>
		<![CDATA[
			import com.hotdraw.java.util.VectorEnumerator;
			
			import mx.collections.ArrayCollection;
			import mx.core.Repeater;
			import mx.events.FlexEvent;
			import mx.managers.PopUpManager;
			
			import org.glomaker.plugin.dragdrop.events.HotspotDeleteEvent;
			import org.glomaker.plugin.dragdrop.events.HotspotTextChangeEvent;
			import org.glomaker.shared.properties.ArrayProperty;
			import org.glomaker.shared.properties.ColourProperty;
			import org.glomaker.shared.properties.IComponentProperty;
			import org.glomaker.shared.properties.NumericStepperProperty;
			import org.glomaker.shared.properties.StringProperty;
			
			//--------------------------------------------------
			// Protected vars
			//--------------------------------------------------
			
			// component properties
			/*
			protected const list1:ArrayProperty = new ArrayProperty("list1", "", ["Item 1","Item 2"]);
			protected const list2:ArrayProperty = new ArrayProperty("list2", "", ["Match 1","Match 2"]);
			protected const submitLabel:StringProperty = new StringProperty("submit", "", "Submit");
			protected const resetLabel:StringProperty = new StringProperty("reset", "", "Reset");
			protected const correctFeedback:StringProperty = new StringProperty("correct", "", "That is correct - well done!");
			protected const wrongFeedback:StringProperty = new StringProperty("wrong", "", "Not quite - try again!");
			protected const connectionColour:ColourProperty = new ColourProperty("connections", "Colour for Connections", 0);
			protected const borderColour:ColourProperty = new ColourProperty("borders", "Colour for Borders of Boxes", 0xB7BABC);
			protected const fontSize:NumericStepperProperty = new NumericStepperProperty("fontSize", "Font Size", 15);
			*/
			
			// other
			[Bindable]
			protected var editMode:Boolean;
			
			[Bindable]
			protected var itemLabels:ArrayCollection;
			
			// Array of HotspotVO instances describing hotspot data
			protected var hotspotData:Array;
			
			// Dictionary mapping Hotspot display objects to HotspotVO instances dict[:Hotspot] = :HotspotVO
			protected var hotspotToVOMap:Dictionary;
			
			
			
			public function fakeInit():void
			{
				// data structures
				hotspotData = new Array();
				hotspotData.push( new HotspotVO( "Item 0 and much longer text to see what happens", 10, 10, 130, 200 ) );
				hotspotData.push( new HotspotVO( "Item 1", 200, 200, 400, 100 ) );
				
				// auxiliary structures
				hotspotToVOMap = new Dictionary(true);
				itemLabels = new ArrayCollection();
				
				// show
				updateList();
				displayHotspots();
			}
			
			
			// data structure
			// each hotspot:
			// index
			// label
			// hotspot x, y, w, h relative to target region
			// general:
			// array of labels for list (shuffled, non shuffled)
			// image url
			// show/hide hotspots during use
			
			
			//--------------------------------------------------
			// Protected functions
			//--------------------------------------------------
			
			protected function displayHotspots():void
			{
				var hotspot:Hotspot;
				for each( var vo:HotspotVO in hotspotData )
				{
					hotspot = createHotspotFromVO( vo );
					targetRegionContainer.addChild( hotspot );
					
					// fade in
					// hotspotFadeIn.target = hotspot;
					// hotspotFadeIn.play();
				}
			}
			
			
			/**
			 * Updates the item list.
			 * Shuffles or not, depending on edit mode.
			 * Use this method rather than calling shuffle / unshuffle directly.
			**/
			protected function updateList():void
			{
				editMode ? unshuffle() : shuffle();
			}
			
			/**
			 * Shuffles the list of draggable labels.
			 * This is achieved by setting the itemLabels property.
			 */
			protected function shuffle():void
			{
				var raw:Array = [];
				var data:Array = hotspotData.concat(); // quick copy for random extraction
				
				// random loop through hotspot array
				var r:int;
				var vo:HotspotVO;
				
				while( data.length > 0 )
				{
					r = Math.floor( Math.random()*data.length );
					vo = data[r];
					data.splice( r, 1 );
					raw.push( vo.text );
				}
				
				// update data provider for list
				itemLabels.source = raw;
			}
			
			/**
			 * Sets the list of draggable labels to the order they were created in.
			 * This is achieved by setting teh itemLabels property.
			 */
			protected function unshuffle():void
			{
				var raw:Array = [];
				for each( var vo:HotspotVO in hotspotData )
				{
					raw.push( vo.text );
				}
				itemLabels.source = raw;
			}

			
			// 
			
			protected var feedback:Feedback;
			protected var result:Result;
			
			protected  function showFeedback(property:StringProperty, title:String = "Enter Feedback"):void
			{
				if(!feedback)
					feedback = new Feedback();
				
				PopUpManager.addPopUp(feedback, this, true);
				PopUpManager.centerPopUp(feedback); 
				
				feedback.relatedProp = property;
				feedback.title = title;
			}
			
			protected  function showResult(correct:Boolean):void
			{
				if(!result)
					result = new Result();
				
				result.correct = correct;
				// result.message = correct ? correctFeedback.propValue : wrongFeedback.propValue;
				
				PopUpManager.addPopUp(result, this, true);
				PopUpManager.centerPopUp(result); 
			}
			
			/**
			 * Creates a Hotspot display object instance for a specified HotspotVO data object.
			**/
			protected function createHotspotFromVO(vo:HotspotVO):Hotspot
			{
				var hotspot:Hotspot = new Hotspot();
				hotspot.labelText = vo.text;
				hotspot.x = vo.x;
				hotspot.y = vo.y;
				hotspot.width = vo.w;
				hotspot.height = vo.h;
				
				// only show controls if in edit mode
				hotspot.showControls = editMode;
				
				// event listeners
				hotspot.addEventListener( HotspotTextChangeEvent.CHANGE, onHotspotTextChange, false, 0, true );
				hotspot.addEventListener( HotspotDeleteEvent.DELETE, onHotspotDelete, false, 0, true );
				
				// add to display list
				targetRegionContainer.addChild( hotspot );
				
				// remember mapping
				hotspotToVOMap[hotspot] = vo;

				// return for further processing
				return hotspot;
			}
			
			/**
			 * Removes hotspot references + data structures and calls its 'remove' function.
			**/
			protected function removeHotspot( hotspot:Hotspot ):void
			{
				// event listeners
				hotspot.removeEventListener( HotspotTextChangeEvent.CHANGE, onHotspotTextChange );
				hotspot.removeEventListener( HotspotDeleteEvent.DELETE, onHotspotDelete );
				
				// data structures
				var vo:HotspotVO = hotspotToVOMap[ hotspot ];
				delete hotspotToVOMap[ hotspot ];
				
				hotspotData.splice( hotspotData.indexOf( vo ), 1 );
				updateList();
				
				// tell the hotspot to remove itself (will animate etc)
				hotspot.remove();
			}

			
			//--------------------------------------------------
			// Overrides
			//--------------------------------------------------
			
			override protected function defineProperties():void
			{
				//addSaveableProperty(list1);				
				// addProperty(connectionColour);
			}
			
			override protected function componentInitComplete():void
			{
			}
			
			override public function editablePropertyUpdated(prop:IComponentProperty):void
			{
				super.editablePropertyUpdated(prop);
			}
			
			override public function prepareValuesForSave():void
			{
				super.prepareValuesForSave();
			}
			
			override public function setEditMode(value:Boolean):void
			{
				super.setEditMode(value);
				
				if (value == editMode)
					return;
				
				editMode = value;
				
				// update display
				updateList();
				
				var obj:DisplayObject;
				for(var i:uint = 0;i<targetRegionContainer.numChildren;i++)
				{
					obj = targetRegionContainer.getChildAt( i );
					if( obj is Hotspot )
					{
						Hotspot( obj ).showControls = editMode;
					}
				}
			}
			
			//--------------------------------------------------
			// Event handlers
			//--------------------------------------------------
			
			protected function addHotspot():void
			{
				// new hotspot data object
				var vo:HotspotVO = new HotspotVO(
					"Click to edit",
					Math.random() * targetRegionContainer.width * 4/5,
					Math.random() * targetRegionContainer.height * 4/5,
					Math.max( 110, targetRegionContainer.width/5 ),
					targetRegionContainer.height/5
				);
				
				// add
				hotspotData.push( vo );
				
				// display object
				var hotspot:Hotspot = createHotspotFromVO( vo );
								
				// fade in
				hotspotFadeIn.target = hotspot;
				hotspotFadeIn.play();
				
				// list
				updateList();
			}
			
			/**
			 * Event handler - hotspot delete was clicked.
			**/
			protected function onHotspotDelete( e:HotspotDeleteEvent ):void
			{
				removeHotspot( Hotspot(e.target) );
			}
			
			/**
			 * Event handler - hotspot text has changed.
			**/
			protected function onHotspotTextChange( e:HotspotTextChangeEvent ):void
			{
				// update the relevant hotspot data VO
				var hotspot:Hotspot = Hotspot( e.target );
				var vo:HotspotVO = hotspotToVOMap[ hotspot ];
				vo.text = e.newText;
				
				// update the appropriate list item
				// relies on the fact that the list is not shuffled in edit mode
				if( editMode )
				{
					// relies on the list being not shuffled in edit mode
					var index:int = hotspotData.indexOf( vo );
					DraggableItem( dragItemList.getChildAt( index ) ).text = vo.text;
					
				}else{
					// this shouldn't happen, as the text field can't be edited 
					updateList();
				}
			}
			
			// ------------------------------
			// DRAGGING CODE
			// ------------------------------
			
			protected var sourceItem:DraggableItem;
			protected var draggedItem:DraggableItem;
			protected var draggedHotspotVO:HotspotVO;
			protected var dragOffset:Point;
			protected var localSourceCoords:Point;
			
			protected function startItemDrag( e:MouseEvent ):void
			{
				sourceItem = DraggableItem( e.target );
				
				// create a copy
				if( draggedItem == null )
				{
					draggedItem = new DraggableItem();
				}
				
				draggedItem.alpha = 0.6;
				draggedItem.width = sourceItem.width;
				draggedItem.styleName = sourceItem.styleName;
				draggedItem.text = sourceItem.text;
				
				// coordinates need converting
				localSourceCoords = new Point( sourceItem.x, sourceItem.y );
				localSourceCoords = sourceItem.parent.localToGlobal( localSourceCoords );
				localSourceCoords = globalToLocal( localSourceCoords );
				
				draggedItem.x = localSourceCoords.x;
				draggedItem.y = localSourceCoords.y;
				
				// add to display list
				addChild( draggedItem );
				
				// start dragging
				dragOffset = new Point( e.localX, e.localY );
				stage.addEventListener( MouseEvent.MOUSE_MOVE, onDragMove );
				stage.addEventListener( MouseEvent.MOUSE_UP, onDragUp );
			}
			
			protected function onDragMove( e:MouseEvent ):void
			{
				var coords:Point = draggedItem.parent.globalToLocal( new Point( e.stageX, e.stageY ) );
				draggedItem.x = coords.x - dragOffset.x;
				draggedItem.y = coords.y - dragOffset.y;
			}
			
			protected function onDragUp( e:MouseEvent ):void
			{
				if( draggedItem )
				{
					noDropMove.target = draggedItem;
					noDropMove.xFrom = draggedItem.x;
					noDropMove.xTo = localSourceCoords.x;
					noDropMove.yFrom = draggedItem.y;
					noDropMove.yTo = localSourceCoords.y;
					noDropMove.play();
				}
				if( sourceItem )
				{
					sourceItem = null;
				}
				stage.removeEventListener( MouseEvent.MOUSE_MOVE, onDragMove );
				stage.removeEventListener( MouseEvent.MOUSE_UP, onDragUp );
			}
			
			protected function onNoDropMoveComplete():void
			{
				if( draggedItem )
				{
					draggedItem.parent.removeChild( draggedItem );
					draggedItem = null;
				}
			}
			
		]]>
	</mx:Script>
	
	<mx:Style>
		.correctFeedbackButton {
			font-size: 9;
			font-weight: normal;
			icon: Embed("assets/tick.png");
		}
		
		.wrongFeedbackButton {
			font-size: 9;
			font-weight: normal;
			icon: Embed("assets/cross.png");
		}
		
		.addButton {
			font-size: 9;
			font-weight: normal;
			icon: Embed("assets/add.png");
		}
		
		.deleteButton {
			font-size: 9;
			font-weight: normal;
			skin: Embed("assets/delete.png");
		}
		
		.listRegion {
			backgroundColor: #f2f2f2;
			borderColor: #858585;
			borderStyle: solid;
			borderThickness: 1;
			borderSides: "right";
			
		}
		.targetRegion{
			backgroundColor: #f9f9f9;
		}
		
		.itemList {
			paddingBottom: 30;
			paddingLeft: 30;
			paddingTop: 30;
			paddingRight: 30;
		}
		
		.listItem {
			backgroundColor: #bfbfbf;
			color: #000000;
			paddingBottom: 8;
			paddingTop: 8;
			paddingLeft: 8;
			paddingRight: 8;
			fontSize: 16;
			borderStyle: solid;
			borderThickness: 2;
			borderColor: #bfbfbf;
		}
		
		.addButton {
			font-size: 9;
			font-weight: normal;
			icon: Embed("assets/add.png");
		}
	</mx:Style>
	
	<mx:Fade id="hotspotFadeIn" duration="300" alphaFrom="0.0" alphaTo="1.0" />
	<mx:Move id="noDropMove" duration="300" effectEnd="onNoDropMoveComplete()" />
	
	<mx:HBox width="100%" height="100%" horizontalGap="0" horizontalScrollPolicy="off" verticalScrollPolicy="off">
		<mx:Canvas
			id="listRegionContainer"
			backgroundColor="#f2f2f2"
			width="163"
			height="100%"
			styleName="listRegion"
			horizontalScrollPolicy="off">
			<mx:VBox id="dragItemList" verticalGap="11" width="163" x="0" y="0" styleName="itemList" horizontalScrollPolicy="off">
				<mx:Repeater dataProvider="{itemLabels}" id="dragRep">
					<dragdrop:DraggableItem
						text="{dragRep.currentItem}"
						styleName="listItem"
						width="95"
						alpha="{editMode?0.3:1.0}"
						buttonMode="true"
						mouseEnabled="{!editMode}"
						mouseDown="startItemDrag(event)"
					/>
				</mx:Repeater>
			</mx:VBox>		
		</mx:Canvas>
		<mx:Canvas
			 width="100%"
			 height="100%"
			 x="163"
			 y="0"
			 styleName="targetRegion"
			 id="targetRegionContainer"
		/>
	</mx:HBox>
	
	<mx:Button id="addButton" click="addHotspot()" visible="{editMode}" label="Add New Hotspot" styleName="addButton" bottom="10" x="{targetRegionContainer.x + (targetRegionContainer.width - addButton.width)/2}" />
	<editbutton:EditableButton id="resetButton" isEditable="{editMode}" label="Reset" bottom="10" x="{(listRegionContainer.width - resetButton.width)/2}"/>
</BaseComponent>